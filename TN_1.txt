***/ 
　　/************ 
　　使用说明，将Cell_1.txt命名为Cell_1.cpp,后编译。 
　　1，将Cell_1复制2份，分别命名为Cell_2，Cell_3。 
　　2，分别点击运行Cell_1，Cell_2，Cell_3。 
　　3，TN1为三个程序共同要处理的问题。 
　　3，得到结果。 
　　***/ 
　　#include 
　　#include 
　　#include 
　　#include 
　　#include 
　　#include 
　　usingnamespacestd; 
　　//设计原理：个体是无意识的，群体在整体的无意识中却 
　　//找到了方向（得到了最优解） 
　　boolIsRight(intNum)//细胞的初始条件:30 
　　{ 
　　if(Num>30&&Num<50) 
　　{ 
　　returntrue; 
　　}else 
　　returnfalse; 
　　} 
　　intCell_No(stringpro_name)//返回细胞自身编号 
　　{ 
　　unsignedintloc1; 
　　loc1=pro_name.find_last_of("_"); 
　　stringfile_no; 
　　intNo=0; 
　　if(loc1!=string::npos) 
　　{ 
　　file_no=pro_name.substr(loc1+1,1); 
　　No=atoi(file_no.c_str()); 
　　} 
　　returnNo; 
　　} 
　　intNext_CellLink(intnowNo,inttotalCellNo)//返回细胞神经连接编号 
　　{ 
　　if(nowNo<=totalCellNo) 
　　{ 
　　returnnowNo; 
　　}else 
　　return(nowNo)%totalCellNo; 
　　} 
　　boolmsg_check(stringfilename,boolcreate=true)//对自身神经连接检查, 
　　{ 
　　fstreamfile; 
　　file.open(filename.c_str(),ios::in); 
　　if(!file) 
　　{ 
　　if(create)file.open(filename.c_str(),ios::out); 
　　elsereturnfalse; 
　　} 
　　file.close(); 
　　returntrue; 
　　} 
　　intrandom(intstart,intend)//细胞根据应激，做出随机反应 
　　{ 
　　srand(time(NULL)); 
　　returnstart+rand()%(end-start); 
　　} 
　　intmain(intargc,char*argv[]) 
　　{ 
　　stringpro_name=*argv; 
　　intno_self=Cell_No(pro_name);//得到自身编号 
　　constinttotal_cell_no=3; 
　　charfile1[10]; 
　　charfile2[10]; 
　　charfile3[10]; 
　　itoa(Next_CellLink(no_self+1,total_cell_no),file1,10); 
　　itoa(Next_CellLink(no_self+2,total_cell_no),file2,10); 
　　itoa(no_self,file3,10); 
　　stringstr_file1=file1; 
　　stringstr_file2=file2; 
　　stringstr_file3=file3; 
　　stringfilename1="N"+str_file1+".txt";//神经1 
　　stringfilename2="N"+str_file2+".txt";//神经2 
　　stringfilename3="Y"+str_file3+".txt";//本身细胞质 
　　//前一级神经连接，由上一级负责，本级负责检查，没有则退出 
　　stringfilename4="TN1.txt"; 
　　if(!msg_check(filename1)||!msg_check(filename2)) 
　　{ 
　　cout<<"Thecelllinkdestroyed."< 
　　} 
　　if(!msg_check(filename3)) 
　　{ 
　　cout<<"Thecytoplasmdestroyed."< 
　　} 
　　if(!msg_check(filename4,true)) 
　　{ 
　　cout<<"Thebeforecelllinkdestroyed."< 
　　system("PAUSE"); 
　　return0; 
　　} 
　　//以上为初始化，细胞完整性自检 
　　inttimes=20;//细胞生命时间 
　　fstreamnfile1,nfile2,yfile,tnfile; 
　　nfile1.open(filename1.c_str(),ios::in); 
　　nfile2.open(filename2.c_str(),ios::in); 
　　yfile.open(filename3.c_str(),ios::in); 
　　tnfile.open(filename4.c_str(),ios::in); 
　　intflag,data,msg_id; 
　　intstudyData=0; 
　　while(times--) 
　　{ 
　　Sleep(2000);//神经 
　　冲动，每2秒检查一次 
　　tnfile.clear(); 
　　tnfile.seekg(0); 
　　tnfile>>flag>>data>>msg_id; 
　　cout<<"Received:"< 
　　cout<<","< 
　　if(!flag||msg_id==no_self)continue;//自身消息和零神经冲动，跳过 
　　if(IsRight(data))//细胞判断,符合 
　　{ 
　　fstreamtnfile2; 
　　boolb_studyWrite=true; 
　　tnfile2.open(filename4.c_str(),ios::out); 
　　if(!tnfile2)cout<<"wrongwrite"< 
　　tnfile2<<0<<''< 
　　tnfile2.flush(); 
　　tnfile2.close(); 
　　inti=0; 
　　yfile.clear(); 
　　yfile.seekg(0); 
　　while(!yfile.eof()) 
　　{ 
　　yfile>>studyData; 
　　i++; 
　　if(studyData==data) 
　　{ 
　　b_studyWrite=false; 
　　break; 
　　} 
　　} 
　　if(b_studyWrite) 
　　{//细胞的学习功能 
　　fstreamyfile_w; 
　　yfile_w.open(filename3.c_str(),ios::out|ios::app); 
　　if(!yfile_w)cout<<"no"< 
　　yfile_w< 
　　yfile_w.flush(); 
　　yfile_w.close(); 
　　//将细胞联系神经信号归零。 
　　fstreamnfile1_w,nfile2_w; 
　　nfile1_w.open(filename1.c_str(),ios::out); 
　　if(!nfile1_w)cout<<"nfile1_wwrongwrite"< 
　　nfile2_w.open(filename2.c_str(),ios::out); 
　　if(!nfile2_w)cout<<"nfile2_wwrongwrite"< 
　　nfile1_w<<0<<''<<0<<''< 
　　nfile2_w<<0<<''<<0<<''< 
　　nfile1_w.close(); 
　　nfile2_w.close(); 
　　} 
　　continue; 
　　}else 
　　{ 
　　fstreamtnfile2,nfile1_w,nfile2_w; 
　　tnfile2.open(filename4.c_str(),ios::out); 
　　if(!tnfile2)cout<<"tnfile2wrongwrite"< 
　　yfile.clear(); 
　　yfile.seekg(0); 
　　yfile>>studyData; 
　　//如果单细胞能够解决，直接解决，不用震荡 
　　//有限性原则，将会导致细胞分化，即学习差异 
　　if(studyData) 
　　{ 
　　tnfile2<<0<<''< 
　　tnfile2.close(); 
　　continue; 
　　}//否则，细胞群震荡计算解决 
　　nfile1_w.open(filename1.c_str(),ios::out); 
　　if(!nfile1_w)cout<<"nfile1_wwrongwrite"< 
　　nfile2_w.open(filename2.c_str(),ios::out); 
　　if(!nfile2_w)cout<<"nfile2_wwrongwrite"< 
　　nfile1.clear(); 
　　nfile1.seekg(0); 
　　nfile1>>flag>>data>>msg_id; 
　　boolnfile1_write; 
　　intresult1=0,result2=0,outdata; 
　　if(!flag||msg_id==no_self)nfile1_write=false; 
　　else 
　　{ 
　　nfile1_write=true; 
　　//计算有限性，如果一个解在有限的范围被解决，将不会扩大范围 
　　//效率和能量最优化原则 
　　if(IsRight(data)) 
　　{ 
　　tnfile2<<0<<''< 
　　tnfile2.close(); 
　　